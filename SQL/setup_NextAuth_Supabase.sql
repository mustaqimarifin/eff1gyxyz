--- PAGES
CREATE TABLE pages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  slug text UNIQUE NOT NULL,
  view_count bigint DEFAULT 1 NOT NULL
);
CREATE OR REPLACE FUNCTION increment_page_view(page_slug TEXT) RETURNS void LANGUAGE plpgsql AS $$ BEGIN IF EXISTS (
    SELECT
    FROM pages
    WHERE slug = page_slug
  ) THEN
UPDATE pages
SET view_count = view_count + 1
WHERE slug = page_slug;
ELSE
INSERT INTO pages(slug)
VALUES (page_slug);
END IF;
END;
$$;
--- USERS//NEXTAUTH
/**
 * USERS
 * Note: This table contains user data. Users should only be able to view and update their own data.
 */
create table users (
  -- UUID from next_auth.users
  id uuid not null primary key,
  name text,
  email text,
  image text,
  constraint "users_id_fkey" foreign key ("id") references next_auth.users (id) match simple on update no action on delete cascade -- if user is deleted in NextAuth they will also be deleted in our public table.
);
alter table users enable row level security;
create policy "Can view own user data." on users for
select using (next_auth.uid() = id);
create policy "Can update own user data." on users for
update using (next_auth.uid() = id);
/**
 * This trigger automatically creates a user entry when a new user signs up via NextAuth.
 */
create function public.handle_new_user() returns trigger as $$ begin
insert into public.users (id, name, email, image)
values (new.id, new.name, new.email, new.image);
return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
after
insert on next_auth.users for each row execute procedure public.handle_new_user();

-- COMMENTS

CREATE TABLE comments (
  id uuid NOT NULL DEFAULT uuid_v7(),
  "pageId" bigint NOT NULL REFERENCES pages (id),
  "authorId" uuid NOT NULL REFERENCES users (id),
  "parentId" uuid NULL REFERENCES comments (id),
  "createdAt" timestamp WITH time zone DEFAULT NOW() NOT NULL,
  "updatedAt" timestamp WITH time zone DEFAULT NOW() NULL,
  "text" text NOT NULL,
  
  PRIMARY KEY (id)
);


ALTER TABLE comments enable ROW LEVEL SECURITY;
CREATE policy "Posts are viewable by everyone." ON comments FOR
SELECT USING (TRUE);

CREATE policy "Users can post as themselves." ON comments FOR
INSERT WITH CHECK (next_auth.uid() = "authorId");

-- Set up Realtime!

BEGIN;
DROP publication IF EXISTS supabase_realtime;
CREATE publication supabase_realtime;
COMMIT;
ALTER publication supabase_realtime
ADD TABLE pages,
  comments,
  users;
  
  
--VIEW

DROP VIEW IF EXISTS "userComments";
CREATE VIEW "userComments" AS
SELECT c.id,
  c.text,
  c."createdAt",
  c."updatedAt",
  p.name,
  p.image,
  s.slug,
  c."authorId",
  c."parentId"
FROM comments c
  INNER JOIN users p ON p.id = c."authorId"
  INNER JOIN pages s ON s.id = c."pageId"